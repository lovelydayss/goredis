# 协程专题整理

## 项目出发

* **非对称有栈协程组件**：参考 libco 实现，基于自实现内存池进行协程模拟栈管理，基于全局单例协程池实现协程统一管理，通过常用网络函数的 hook 劫持，采用 epoll 方法实现网络操作异步逻辑的同步式调用。

* **C++20 无栈协程组件**：基于泛型思想，在 C++20 coroutine 协程标准库基础上封装实现通用 future 任务类型，支持 async / await 式协程调用。支持指定线程、线程池，线程任务循环在内的多种方法进行协程调度。

## 进程、线程、协程的区别

* 首先也是最核心的的一个区别在于进程和线程分别对应着操作系统持有资源和调度的基本单位，运行在内核态，而协程则运行在用户态，与操作系统内核无关
* 对于进程而言，其拥有独立的上下文去描述其拥有的内存空间、文件描述符、环境变量、信号上下文等，进程间互不干扰，一个进程崩溃不会影响到其他进程的运行，而对于线程来说，其共享所在进程的进程上下文资源，仅拥有独立的寄存器组、堆栈等资源，单个线程崩溃会导致其所在的整个进程的崩溃。
* 进而在发生调度时，操作系统切换进程需要切换整个上下文的资源，开销较大，而线程仅需要对其独立的寄存器堆栈进行切换即可，开销较小。
* 除此之外，在通信方面，由于进程间相互隔离，因此通常需要采用如管道，消息队列，内存映射等操作系统机制进行通信，而对于线程而言，其共享进程内内存空间，一般直接操作即可，因此也是存在临界资源竞争问题，需要采用一系列同步手段进行处理。
* 如前所述，线程和进程运行在内核态，因此在调度切换过程中不可避免的需要经过系统调用，陷入等一系列操作以陷入内核，开销较大，因此引入了协程也就是用户态线程的概念，协程运行在用户态，其在切换时一般等同于函数的调用，开销也会更小一些。

* 不过这个区分其实也只是一个理论上的区分，在具体实现上也和操作系统有关，如 linux 就使用的同一套 task_struct 去描述进程和线程，仅在资源共享方面有所区别。

## 扩展到 linux 线程调度




## fork 等创建子进程，写时复制




## 灵魂拷问，有栈协程无栈协程的区别在哪里

对于一个协程的切换，一般意义上主要需要考虑两个方面，即切换的目标位置（就是PC寄存器）还有当前区域的一些局部变量也就是（寄存器组以及栈帧），有栈协程和无栈协程的区别即由此展开：

对于我实现的这个非对称有栈协程来说，其会在堆上主动开辟一块空间作为自己的协程栈，去存储当前的局部变量信息，与此同时，每个协程会维护一份自己的寄存器组，当发生协程切换时候通过寄存器组的切换去实现修改当前执行位置以及栈空间位置，进而实现协程的切换以及分段执行。

而 C++20 无栈协程采用的则是一种原地实现的方案，其会通过编译器的支持去将设置的协程体定义去解析成 coroutine_frame 结构体和 coroutine_resume 函数，在 coroutine_frame 结构体中对当前的局部变量和协程中断点进行存储（也就是说在这里会根据协程实际使用情况去零散堆把变量放到堆上而不是分配一片连续堆栈空间），然后在 resume 函数中通过宏扩展去使用 switch 实现协程调用的状态机，即通过 switch 的不同 case 配合 goto 跳转到 coroutine_frame 结构体保存的各个标签(co_await 触发点) 实现对于协程切换，最终实现分段执行。

## 两者的优缺点

从两者的区别出发其实就可以很好的发现他们的优缺点：

有栈协程的优势主要在于实现和使用的方便上：

* 对于有栈协程来说，其将所有的局部变量存放在自己的栈中，通过寄存器组切换来维护协程跳转以及分段执行，这样一个比较大的优势就是实现起来相对简单，也比较好理解，而无栈协程的实现思路包括实现宏扩展，局部变量维护等较为复杂，C++20 协程因此也是实现了较多的编译器支持。

* 对于 C++20 无栈协程来说其采用了类似于 async/await 那一套语法，这具有一定的传染性，也就是说对于一个子任务是协程的话如果不采用像 then / 或者是阻塞读等操作的话其本身也必须被标识成协程，在使用上可能存在一定的不便。 

而无栈协程的优势则主要体现在性能方面，这也是 C++20 选择无栈实现的原因：

* 因为无栈协程属于是给每一个协程默认分配相同大小的栈，所以当协程所需内存大于栈空间时可能会发生爆栈，当协程所需内存较小时候也会导致严重的浪费。在这方面无栈协程则是随用随分配，不会有这空间上的担忧。

* 此外，由于有栈协程是靠用户态手动切换寄存器组实现的执行跳转，这样的操作会很大程度上打断 cpu 的执行预测，进而产生一定的性能损耗，而无栈协程则主要靠的是原地构造 switch 语句然后原地跳转，不会有这方面的开销，一般情况来说性能要比有栈协程要更好。

## C++ 20 协程实现

C++ 20 协程属于一种无栈协程的实现，不过 C++ coroutine 属于是面向库开发者的作品，只是做了一点简单封装，比较底层

在组成方面，C++20 协程主要实现的协程函数体，控制生命周期的 handle ，返回类型约束 promise_type 这些部分组成

在编译过程中其会通过编译器的支持去将设置的协程体定义去解析成 coroutine_frame 结构体和 coroutine_resume 函数，在 coroutine_frame 结构体中对当前的局部变量和协程中断点进行存储（也就是说在这里会根据协程实际使用情况去零散堆把变量放到堆上而不是分配一片连续堆栈空间），然后在 resume 函数中通过宏扩展去使用 switch 实现协程调用的状态机，即通过 switch 的不同 case 配合 goto 跳转到 coroutine_frame 结构体保存的各个标签(co_await 触发点) 实现对于协程切换，最终实现分段执行。



## C++ async 库与此处协程的区别

C++ async 库内部实现是一个线程池，通过采用 async 可以实现将任务交给线程池去异步执行，调用方使用 future 去完成执行结果的获取以及同步。而此处协程使用 await 拉起的虽然同样是一个异步执行情况，通过我这里自己实现的一个类似于 future 的类型进行结果获取，但采用的则是一个用户态协程去执行，其绑定到线程上的逻辑由调度器去完成。

它们两个虽然同样是异步操作，核心差异在于任务执行是由用户态的协程还是内核态的线程来完成的。


## golang 协程实现

golang 主要采用的是一个有栈协程，其对于每个协程都会根据其内存管理方法有独立的缓存 mcache 去维护变量，同时编译器会对变量分配进行灵活调节。同时其也是一种非对称协程，每次协程切换都会先切换到 g0 再切换到指定协程。

## 参考文献

> [万字好文：从无栈协程到C++异步框架！](https://segmentfault.com/a/1190000042774162)

> [再探 C++20 协程](https://sf-zhou.github.io/coroutine/cpp_20_explore_coroutines.html)